<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">



<title>ISourceCodeContext</title>
<link rel="stylesheet" type="text/css" href="PLUGINS_ROOT/PRODUCT_PLUGIN/book.css">
</head>

<body>

<h1>ISourceCodeContext - Where are We?</h1>
<p>Many IDE operations require some kind of source code to operate in, code completion, browsing, hovers and type
inference being some of these operations. ISourceCodeContext is the answer to the question <em>Where in the source
are we?</em></p>
<p>Classes and interfaces are found in the package <em>org.codehaus.eclipse.core.context</em>.</p>
<p>The interface is defined as:</p>
<p class="Code">public interface ISourceCodeContext {<br>
&nbsp;&nbsp;&nbsp; String getId();
&nbsp;&nbsp;&nbsp; ASTNode[] getASTPath();<br>
&nbsp;&nbsp;&nbsp; int getSourceLine();<br>
&nbsp;&nbsp;&nbsp; int getSourceColumn();<br>
}</p>
<p>The method <em>getASTPath()</em> is descibed later in this document.</p>

<h2>The Different Types of ISourceCodeContexts</h2>
<p>ISourceCodeContext is not meant to be implemented by clients. Several context implementations exist. They all have
an ID prefixed with <em>org.codehaus.groovy.eclipse.core.context.</em></p>
<h3>Module Context</h3>

ID: org.codehaus.groovy.eclipse.core.context.module
<br>

This context is active anywhere in Groovy source code. It answers the question&nbsp;
<em>am I anywhere in groovy source?</em>
<br>

<h3>Module Scope Context</h3>

ID: org.codehaus.groovy.eclipse.core.context.moduleScope
<br>

Module scope is any place outside of classes. Package and import declarations are defined in module scope context.
<br>

Note that if the source file is a Groovy script, then variables and functions are NOT in the module scope context, but
rather are implicitly defined within a script class and special script 'run()'method.
<br>

<h3>Class Context</h3>

ID: org.codehaus.groovy.eclipse.core.context.class
<br>

Anywhere inside a class, including methods.
<br>

<h3>Class Scope Context</h3>

ID: org.codehaus.groovy.eclipse.core.context.classScope
<br>

Anywhere where&nbsp;fields, properties and methods are declared, but not inside methods or closures.
<br>

<h3>Constructor Scope Context</h3>

ID: org.codehaus.groovy.eclipse.core.context.constructorScope
<br>

Inside any constructor block.
<br>

<h3>Contructor Parameters Context</h3>

ID: org.codehaus.groovy.eclipse.core.context.contructorParameters
<br>

Inside the parameter list of a contructor declaration.
<br>

<h3>Method Scope Context</h3>

ID: org.codehaus.groovy.eclipse.core.context.methodScope
<br>

Inside any method block.
<br>

<h3>Method Parameters Context</h3>

ID: org.codehaus.groovy.eclipse.core.context.methodParameters
<br>

Inside the parameter list of a method declaration.
<br>

<h3>Closure Scope Context</h3>

ID: org.codehaus.groovy.eclipse.core.context.closureScope
<br>

Inside any closure. This context may be defined when inside closure that is inside a method or is a&nbsp;field
initializer.
<br>

<br>

<span style="font-weight: bold;">Important:</span>
If desiging code to be active within the scope of a method, the closure scope context may also be present if the closure
is nested within a method. The code should therefore be active within both method scope and closure scope in order to be
actived properly.
<br>

<h2>Creating a Context</h2>

Contexts are normally created with the
<em>SourceCodeContextFactory.</em>
<br>

<br>

Example: Getting the contexts at some location in source code.
<p class="Code">ISourceCodeContext[] createContexts(ModuleNode moduleNode, ISourceBuffer buffer, int offset) {<br>
&nbsp;&nbsp;&nbsp; int[] lineCol = buffer.toLineColumn(offset);<br>
&nbsp;&nbsp;&nbsp; SourceCodeContextFactory factory = new SourceCodeContextFactory();<br>
&nbsp;&nbsp;&nbsp; return factory.createContexts(buffer, moduleNode, lineCol[0], lineCol[1]);<br>
}<br>
</p>

The Players:
<br>

<em>org.codehaus.groovy.ast.ModuleNode</em>
is the AST generated by compiling some Groovy code.
<br>

<em>org.codehaus.groovy.eclipse.core.ISourceBuffer</em>
is used throughout the IDE. It is a simple wrapper around some source code. Its understands source code locations in
terms of offsets, but can convert between line, column and offset coordinates, both of which are used in GroovyEclipse.
<br>

The result is an array of contexts sorted in the order they are encountered. A typical array would look like:
<br>

[module, classScope, methodScope, closureScope] ie a closure inside of a method.
<br>

The context
<em>module</em>
is always guaranteed to exist.
<br>

<br>

<h2>Using a Context</h2>

The context can now be used in code completers, type evaluators and whatever other type of code that depends on a known
context. Typically, once discovering that the context of interest exists, the current AST nodes are required:
<br>

<p class="Code">context.getASTPath()</p>

This path contains all AST nodes that were traversed to reach the current location. Since most of the&nbsp;AST nodes
don't contain links to their parent nodes, the path is useful to get to a parent. For example, if the current context is
a closure scope context, we might want to find the enclosing method if there is one:
<br>

<p class="Code">if (contexts.find { it.id ==&nbsp;ISourceCodeContext.METHOD_SCOPE }) {<br>
&nbsp;&nbsp;&nbsp; // do something interesting in method scope<br>
}<br>
</p>
Now something interesting can be done, e.g. completion on some variable.
</body>
</html>
